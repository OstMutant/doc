-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
YAML(https://habr.com/post/238603/, https://dzone.com/articles/using-yaml-java-application, https://ru.wikipedia.org/wiki/YAML)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
YAML — человекочитаемый формат сериализации данных, концептуально близкий к языкам разметки, но ориентированный на удобство ввода-вывода типичных структур данных многих языков программирования.
Yet Another Markup Language(«Ещё один язык разметки») 
YAML: YAML Ain't Markup Language
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
XML(https://jsehelper.blogspot.com/2016/01/xml.html)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	XML(eXtensible Markup Language - расширяемый язык разметки) - текстовый форм предназначенный для хранения структурированных данных (взамен существующ файлов баз данных),
		для обмена информацией между программами.
	
	Валидность XML-документа определяется наличием DTD или XML-схема(XSD) и соблюдением правил, которые там приведены.
	XQuery - это универсальный язык запросов к XML-данным, содержащий средства для выборки, так и для трансформации XML-данных.(https://www.tutorialspoint.com/xquery/xquery_quick_guide.htm, https://www.w3schools.com/xml/xquery_intro.asp)
		XQuery FLWOR Expressions
			FLWOR (pronounced "flower") is an acronym for "For, Let, Where, Order by, Return".
				For - selects a sequence of nodes
				Let - binds a sequence to a variable
				Where - filters the nodes
				Order by - sorts the nodes
				Return - what to return (gets evaluated once for every node)
			XQuery Comparisons
				1. General comparisons: =, !=, <, <=, >, >=  ($bookstore//book/@q > 10)
				2. Value comparisons: eq, ne, lt, le, gt, ge  ($bookstore//book/@q gt 10)
			XQuery Conditional Expressions
				"If-Then-Else" expressions are allowed in XQuery.
					for $x in doc("books.xml")/bookstore/book
					return if ($x/@category="CHILDREN")
					then <child>{data($x/title)}</child>
					else <adult>{data($x/title)}</adult>
	XPath (XML Path Language) - это язык запросов который предназначен произвольного обращения к частям XML или XHTML документа. 
		Строка XPath - это фактически путь к элементу в дереве, где каждый уров разделяется косой чертой «/».
	Изменение в XML можно сделать с помощью DOM и XPATH.
	XPath can be used to navigate through elements and attributes in an XML document.(https://www.w3schools.com/xml/xpath_intro.asp)
	
	DOM, SAX, STAX АНАЛИЗАТОРЫ
		DOM (Document Object Model - объектная модель документов) - платформен независимый программный интерфейс, позволяющий программами скрип
			управлять содержимым документов HTML и XML, а также изменять их структур оформление. 
		SAX (Simple API for XML) базируется на модели последовательной одноразової обработки и не создает внутренних деревьев.
		StAX (Streaming API for XML) не создает дерево объектов в памяти, но, в отличие от SAX-парсера, за переход от одной вершины XML к другой отвечает приложен
			которое запускает разбор документа.

	XSL (eXtensible Stylesheet Language) is a styling language for XML.(https://www.w3schools.com/xml/xsl_intro.asp)
		XSLT stands for XSL Transformations.
	XSLT (eXtensible Stylesheet Language Transformations) - расширяемый язик преобразования листов стилей.
		Язык XSLT служит транслятором, с помощью которого можно свободно модифицировать исходный текст.
	
	JAXP состоит из четырех пакетов. В них вы найдете интерфейсы и класи предназначенные для анализа и преобразования XML-данных.
		javax.xml.parsers - общий интерфейс для анализаторов DOM и SAX.
		org.w3c.dom - общий API для работы с DOM в Java.
		org.xml.sax - определяет интерфейсы, использованные для анализаторов SAX.
		javax.xml.transform - API XLST для преобразования XML в другие типы документов
		
	JAXP (Java API for XML Processing) - набор абстрактных API, упрощающих обработку XML данных с помощью программ, написанных на Java.
		Усиливает стандартние анализаторы SAX (Simple API for XML Parsing) и DOM (Document Object Model). 
		Также поддерживает преобразования расширяемого языка таблиц стилей (XSLT стандарт, давая вам контроль над представлением данных и позволяя преобразов
			данные в другие XML-документы или в другие форматы, такие как HTML.
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JAXB(https://uk.wikipedia.org/wiki/JAXB, http://docs.oracle.com/javaee/5/api/index.html?javax/xml/bind/JAXBContext.html)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	Java Архітектура для XML Binding (JAXB) дозволяє розробникам відображати(ставити у відповідність) класи Java у XML файли.
	JAXB має дві основні властивості: здатність створювати класи Java з XML і навпаки - створювати XML файли з класів Java.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON (https://tproger.ru/translations/java-json-library-comparison/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	JSON.simple от Yidong Fang. Небольшая и легковесная библиотека для кодирования и декодирования JSON, несмотря на свою простоту, выполняет свою работу на высоком уровне.
	GSON от Google. Библиотека, которая умеет конвертировать Java объекты в JSON и наоборот. Не требует специальным образом аннотировать классы, а также в качестве бонуса имеет полную поддержку Java Generics.
	Отсутствие необходимости добавления аннотаций упрощает реализацию и даже может быть главным требованием, если вы собираетесь сериализовывать объекты, не имея для них исходного кода.
	Jackson от FasterXML. Набор инструментов для обработки данных, основанный на потоковом JSON-парсере и генераторе. Предназначенная для Java библиотека умеет работать не только с JSON.
	Имеет самый популярный JSON-парсер (исходя из статистики использования на GitHub).
	JSONP от Oracle. API для работы с JSON, а именно для генерации и разбора потоковых JSON-текстов. Эталонная реализация JSR353 с открытым исходным кодом.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON vs XML (https://www.geeksforgeeks.org/difference-between-json-and-xml/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JSON																				XML
It is JavaScript Object Notation													It is Extensible markup language
It is based on JavaScript language.													It is derived from SGML.
It is a way of representing objects.												It is a markup language and uses tag structure to represent data items.
It does not provides any support for namespaces.									It supports namespaces.
It supports array.																	It doesn’t supports array.
Its files are very easy to read as compared to XML.									Its documents are comparatively difficult to read and interpret.
It doesn’t use end tag.																It has start and end tags.
It is less secured.																	It is more secured than JSON.
It doesn’t supports comments.														It supports comments.
It supports only UTF-8 encoding.													It supports various encoding.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JDBC API в Java - обзор и туториал(http://www.javenue.info/post/java-jdbc-api, http://www.quizful.net/post/using-jdbc, http://proselyte.net/tutorials/jdbc/statements/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database.
		It is Java based data access technology and used for Java database connectivity. 
		It is part of the Java Standard Edition platform, from Oracle Corporation. (https://en.wikipedia.org/wiki/Java_Database_Connectivity)

	Основные сущности в JDBC API, с которыми вам предстоит работать, являются интерфейсами:
		Connection; Statement; PreparedStatement; CallableStatement; ResultSet; Driver; DatabaseMetaData.
	
	З'єднання з базою даних описується класом, що реалізує інтерфейс java.sql.Connection.
		Маючи з'єднання з базою даних, можна створювати об'єкти типу Statement, використовувані для здійснення запитів до бази даних на мові SQL.

	Існують такі види типів Statement, що відрізняються своїм призначенням:

		java.sql.Statement — Statement загального призначення;
		java.sql.PreparedStatement — Statement, що служить для здійснення запитів, котрі містять підставні параметри (позначаються символом '?' у тілі запиту);
		java.sql.CallableStatement — Statement, призначений для виклику збережених процедур.
		
	JDBC represents statements using one of the following classes:(https://en.wikipedia.org/wiki/Java_Database_Connectivity)
		Statement – the statement is sent to the database server each and every time.
		PreparedStatement – the statement is cached and then the execution path is pre-determined on the database server allowing 
			it to be executed multiple times in an efficient manner.
		CallableStatement – used for executing stored procedures on the database.
		
	Клас java.sql.ResultSet дозволяє легко обробляти результати запитів.
	
	Когда мы должны использовать PreparedStatement вместо Statement?(https://articles.javatalks.ru/articles/2)
		запрос перезаписывается и компилируется сервером базы данных
		защита от SQL-инъекций
	
	try (Connection conn = DriverManager.getConnection(
		"jdbc:somejdbcvendor:other data needed by some jdbc vendor",
		"myLogin",
		"myPassword" ) ) {
		/* you use the connection here */
	}
	
	JDBC - Transactions(https://www.tutorialspoint.com/jdbc/jdbc-transactions.htm)
		Commit & Rollback
			code the following to turn off auto-commit − conn.setAutoCommit(false);
			Once you are done with your changes and you want to commit the changes then call commit() method on connection object as follows − conn.commit( );
			Otherwise, to roll back updates to the database made using the Connection named conn, use the following code − conn.rollback( );
	
	Benefits of Java Prepared Statement(http://javarevisited.blogspot.com/2012/03/why-use-preparedstatement-in-java-jdbc.html)
		1. PreparedStatement allows you to write dynamic and parametric query.
		2. PreparedStatement is faster than Statement in Java
		3. PreparedStatement prevents SQL Injection attacks in Java
		4. At last PreparedStatement queries are more readable and secure than cluttered string concatenated queries.
		
	There are two levels of potential reuse for a PreparedStatement.(http://tutorials.jenkov.com/jdbc/preparedstatement.html)
		Reuse of PreparedStatement by the JDBC driver.
		Reuse of PreparedStatement by the database.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java: hashCode, equals (https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--, https://habrahabr.ru/post/168195/, https://ru.stackoverflow.com/questions/308289/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-hashcode-%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B5, https://parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-2)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	The general contract of hashCode is:
		Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, 
			provided no information used in equals comparisons on the object is modified. 
			This integer need not remain consistent from one execution of an application to another execution of the same application.
		If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
		It is not required that if two objects are unequal according to the equals(java.lang.Object) method, 
			then calling the hashCode method on each of the two objects must produce distinct integer results.
			However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.

	Класс HashMap реализован с использованием метода цепочек, т.е. каждой ячейке массива соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список.

	Метод equals() должен обеспечивать:
		симметричность (для любых ненулевых ссылок x и y метод x.equals(y) должен возвращать true тогда и только тогда, когда y.equals(x) возвращает true);
		рефлексивность (для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.);
		транзитивность (для любых ненулевых ссылок x, y и z, если x.equals(y) возвращает true и y.equals(z)возвращает true, тогда и x.equals(z) должен возвращать true).
		Также есть ещё два свойства: постоянство и неравенство null.
		It is reflexive: for any non-null reference value x, x.equals(x) should return true.
		It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
		It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
		It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false,
			provided no information used in equals comparisons on the objects is modified.
		For any non-null reference value x, x.equals(null) should return false.

	http://commons.apache.org/proper/commons-lang/ - Lang provides a host of helper utilities for the java.lang API, notably String manipulation methods, 
		basic numerical methods, object reflection, concurrency, creation and serialization and System properties. 
		Additionally it contains basic enhancements to java.util.Date and a series of utilities dedicated to help with building methods, such as hashCode, toString and equals.
	
	Класс IdentityHashMap(https://jsehelper.blogspot.com/2016/01/java-collections-framework-3.html,http://proselyte.net/tutorials/java-core/collections-framework/identity-hashmap/) 
	является реализацией абстрактного класса AbstractMap. Его отличие от HashMap состоит в том, что при сравнении элементов используется сравнение ссылок, а не значений.
	При сравнении не используется класс equals(). Этот класс обеспечивает постоянное время для операция добавления и получения элемента 
	и формирует хэш-код с помощью метода Systen.identityHashCode(Object).
	Реализация по умолчанию hashCode() возвращает значение, которое называется идентификационный хеш (identity hash code).
	
	XX:hashCode=n(https://habrahabr.ru/post/165683/)
	As we saw, this happens at get_next_hash. This function offers six methods based on the value of some hashCode variable. (https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html)
		0. A randomly generated number.
		1. A function of memory address of the object.
		2. A hardcoded 1 (used for sensitivity testing.)
		3. A sequence.
		4. The memory address of the object, cast to int.
		5. Thread state combined with xorshift (https://en.wikipedia.org/wiki/Xorshift)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OOP 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------- Polymorphism in Java (https://www.baeldung.com/java-interfaces, https://www.geeksforgeeks.org/overriding-in-java/, https://blog.udemy.com/polymorphism-in-java/)
		We cover two core types of polymorphism: static or compile-time polymorphism and dynamic or runtime polymorphism. 
			Static polymorphism is enforced at compile time while dynamic polymorphism is realized at runtime.
			
		The static polymorphism (also known as compile time polymorphism) is implemented via overloaded methods of a class.
		Dynamic Polymorphism is implemented in Java using overridden methods. Method overrides refer to the process of providing the same method name but with different parameters.
		
		@Override (https://www.tutorialspoint.com/importance-of-override-annotation-in-java, https://beginnersbook.com/2014/07/override-annotation-in-java/)
		The @Override annotation is one of a default Java annotation and it can be introduced in Java 1.5 Version. The @Override annotation indicates that the child class method is over-writing its base class method.
			The @Override annotation can be useful for two reasons
				It extracts a warning from the compiler if the annotated method doesn't actually override anything.
				It can improve the readability of the source code.
				
----------------- Inheritance in Java (https://www.geeksforgeeks.org/inheritance-in-java/)				
		Inheritance is an important pillar of OOP(Object Oriented Programming). It is the mechanism in java by which one class is allow to inherit the features(fields and methods) of another class.
		Important terminology:
		Super Class: The class whose features are inherited is known as super class(or a base class or a parent class).
		Sub Class: The class that inherits the other class is known as sub class(or a derived class, extended class, or child class). 
			The subclass can add its own fields and methods in addition to the superclass fields and methods.
		Reusability: Inheritance supports the concept of “reusability”, i.e.
			when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. 
			By doing this, we are reusing the fields and methods of the existing class.
			

----------------- Encapsulation in Java (https://www.geeksforgeeks.org/encapsulation-in-java/?ref=lbp)
		Encapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates.
			Other way to think about encapsulation is, it is a protective shield that prevents the data from being accessed by the code outside this shield.
			Technically in encapsulation, the variables or data of a class is hidden from any other class and can be accessed only through any member function of own class in which they are declared.
			As in encapsulation, the data in a class is hidden from other classes using the data hiding concept which is achieved by making the members or methods of class as private and the class is exposed to the end user
				or the world without providing any details behind implementation using the abstraction concept, so it is also known as combination of data-hiding and abstraction..
			Encapsulation can be achieved by: Declaring all the variables in the class as private and writing public methods in the class to set and get the values of variables.

		Модификаторы доступа(http://ocpj8.javastudyguide.com/ch01.html):
			public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
			private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
			protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
			Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

			-- Accessors and Mutators(https://www.thoughtco.com/accessors-and-mutators-2034335):
				Accessor method is used to return the value of a private field.
				Mutator method is used to set a value of a private field. 
					Why Use Accessors and Mutators? 
						Change how the data is handled behind the scenes.
						Impose validation on the values that the fields are being set to.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What Are Interfaces in Java? (https://www.baeldung.com/java-interfaces)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	In Java, an interface is an abstract type that contains a collection of methods and constant variables. 
		It is one of the core concepts in Java and is used to achieve abstraction, polymorphism and multiple inheritances.
	
	Rules for Creating Interfaces
		In an interface, we're allowed to use:

		constants variables
		abstract methods
		static methods
		default methods
		We also should remember that:

		we can't instantiate interfaces directly
		an interface can be empty, with no methods or variables in it
		we can't use the final word in the interface definition, as it will result in a compiler error
		all interface declarations should have the public or default access modifier; the abstract modifier will be added automatically by the compiler
		an interface method can't be private, protected, or final
		interface variables are public, static, and final by definition; we're not allowed to change their visibility
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Immutable Class (https://www.journaldev.com/129/how-to-create-immutable-class-in-java, https://www.jworks.io/immutable-data-structures-in-java/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	To create immutable class in java, you have to do following steps.
		Declare the class as final so it can’t be extended.
		Make all fields private so that direct access is not allowed.
		Don’t provide setter methods for variables
		Make all mutable fields final so that it’s value can be assigned only once.
		Initialize all the fields via a constructor performing deep copy.
		Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.
	
	Benefits of Programming with Immutable Objects in Java (https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java/)
		Immutable objects are thread-safe so you will not have any synchronization issues.
		Immutable objects are good Map keys and Set elements, since these typically do not change once created.
		Immutability makes it easier to write, use and reason about the code (class invariant is established once and then unchanged)
		Immutability makes it easier to parallelize your program as there are no conflicts among objects.
		The internal state of your program will be consistent even if you have exceptions.
		References to immutable objects can be cached as they are not going to change.
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Generics – Generics in Java (https://www.journaldev.com/1663/java-generics-example-method-class-interface)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Generics was added in Java 5 to provide compile-time type checking and removing risk of ClassCastException that was common while working with collection classes. 
	We use angle brackets (<>) to specify the type parameter.
	Java Generic Type
		Naming convention helps us understanding code easily and having a naming convention is one of the best practices of java programming language. 
		So generics also comes with it’s own naming conventions. Usually type parameter names are single, uppercase letters to make it easily distinguishable from java variables. 
		The most commonly used type parameter names are:
			E – Element (used extensively by the Java Collections Framework, for example ArrayList, Set etc.) K – Key (Used in Map) N – Number T – Type V – Value (Used in Map) S,U,V etc. – 2nd, 3rd, 4th types
	Java Generic Interface
		public interface Comparable<T> {
			public int compareTo(T o);
		}
	Java Generic Class 
		public class GenericsType<T> {
			private T t;
			public T get(){
				return this.t;
			}
			public void set(T t1){
				this.t=t1;
			}
		}
	Java Generic Method
		public static <T> boolean isEqual(GenericsType<T> g1, GenericsType<T> g2){
			return g1.get().equals(g2.get());
		}
	Java Generics and Inheritance
		We know that Java inheritance allows us to assign a variable A to another variable B if A is subclass of B. 
		So we might think that any generic type of A can be assigned to generic type of B, but it’s not the case.
			public class GenericsInheritance {
				public static void main(String[] args) {
					String str = "abc";
					Object obj = new Object();
					obj=str; // works because String is-a Object, inheritance in java
					MyClass<String> myClass1 = new MyClass<String>();
					MyClass<Object> myClass2 = new MyClass<Object>();
					//myClass2=myClass1; // compilation error since MyClass<String> is not a MyClass<Object>
					obj = myClass1; // MyClass<T> parent is Object
				}
				public static class MyClass<T>{}
			}
			
	Using Wildcards with Generics(https://www.baeldung.com/java-generics)
		Wildcards are represented by the question mark in Java “?” and they are used to refer to an unknown type. 
		The wildcard ? in Java is a special type parameter that controls the type safety of the use of generic (parameterized) types.
			It can be used in variable declarations and instantiations as well as in method definitions, but not in the definition of a generic type.
	Java Generics Wildcards
		Question mark (?) is the wildcard in generics and represent an unknown type. The wildcard can be used as the type of a parameter, field, or local variable and sometimes as a return type. 
			We can’t use wildcards while invoking a generic method or instantiating a generic class. In following sections, we will learn about upper bounded wildcards, lower bounded wildcards, and wildcard capture.
	Java Generics Upper Bounded Wildcard
		List<? extends Number> list  - Upper bounded wildcards are used to relax the restriction on the type of variable in a method. 
	Java Generics Unbounded Wildcard
		<? extends Object> - Sometimes we have a situation where we want our generic method to be working with all types, in this case unbounded wildcard can be used. Its same as using 
	Java Generics Lower bounded Wildcard
	    <? super Integer> list
	Java Generics Type Erasure
		Generics in Java was added to provide type-checking at compile time and it has no use at run time, 
			so java compiler uses type erasure feature to remove all the generics type checking code in byte code and insert type-casting if necessary. 
			Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.

	Multiple Bounded Type Parameter
		public abstract class Cage<T extends Animal & Comparable>
--------------------
		Мнемоника PECS (provider - extends, consumer - super)(https://ru.stackoverflow.com/questions/361807/%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-wildcard-%D0%B2-generics-java)
		"PECS" находится с точки сбора. Если вы только вытаскиваете предметы из общей коллекции, это производитель, и вы должны использовать extends;
		если вы только набиваете предметы, это потребитель, и вы должны использовать super. Если вы делаете оба с одной и той же коллекцией, вы не должны использовать либо extends, либо super.

		<? extends Number> подразумевается "любой тип, являющийся дочерним классом для Number". Плюс сам Number.
		<? super Number> действительно подразумевает "любой тип, являющийся супер-классом для Number". Плюс сам Number.
 
		Бриллиантовая операция (Diamond operator)(https://urvanov.ru/2016/04/28/java-8-%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F/)
		Начиная с Java 7 существует также бриллиантовая операция (--[diamond operator]--), которая позволяет указывать пустые аргументы типа <>  там, где компилятор может вывести тип из контекста: 
			Lair<Goblin> goblinLair = new Lair<>();
		Сырой тип (--[raw type]--) — это имя обобщённого класса или интерфейса без аргументов типа (type arguments).
		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Memory Management in Java 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	--- (https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java)
		Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.
		JVM memory is divided into separate parts. At broad level, JVM Heap memory is physically divided into two parts – Young Generation and Old Generation.
		Young Generation is divided into three parts – Eden Memory and two Survivor Memory spaces.
	
	--- The off-heap memory is composed of:(https://allegro.tech/2016/09/CQK-TOP-10-gc.html)
		--- 1. Metaspace — memory for class metadata.
			--- Permanent Generation or “Perm Gen” contains the application metadata required by the JVM to describe the classes and methods used in the application. Note that Perm Gen is not part of Java Heap memory.
				When stack memory is full, Java runtime throws java.lang.StackOverFlowError whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
				--- Method Area is part of space in the Perm Gen and used to store class structure (runtime constants and static variables) and code for methods and constructors.
					--- Runtime constant pool is per-class runtime representation of constant pool in a class. It contains class runtime constants and static methods. Runtime constant pool is the part of method area.
				--- Memory Pools are created by JVM memory managers to create a pool of immutable objects, if implementation supports it. String Pool is a good example of this kind of memory pool. 
					Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.
			--- Meta Space(https://dzone.com/articles/understanding-the-java-memory-model-and-the-garbag): This memory is out of heap memory and part of the native memory. 
				As per the document by default the meta space doesn’t have an upper limit. 
				In earlier versions of Java we called this “Perm Gen Space". This space is used to store the class definitions loaded by class loaders. 
				This is designed to grow in order to avoid 0ut of memory errors. However, if it grows more than the available physical memory, then the operating system will use virtual memory. 
				This will have an adverse effect on application performance, as swapping the data from virtual memory to physical memory and vice versa is a costly operation. 
				We have JVM options to limit the Meta Space used by the JVM. In that case, we may get out of memory errors.
		--- 2. Code cache — memory for the compiled code. (https://stackoverflow.com/questions/35840980/jvm-about-code-cache-area)
			Code Cache: JVM has an interpreter to interpret the byte code and convert it into hardware dependent machine code. As part of JVM optimization, the Just In Time (JIT) compiler has been introduced.
			The frequently accessed code blocks will be compiled to native code by the JIT and stored it in code cache. The JIT compiled code will not be interpreted.	
		--- 3. Thread stacks — every thread preallocates memory for a call stack, by default it is 1MB on 64-bit systems.
			--- Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method. 	
				Трассировка стека – это список методов, которые были вызваны до момента, когда в приложении произошло исключение.
		--- 4. Memory allocated with sun.misc.Unsafe#allocateMemory, it may be used e.g. by caches to limit time spent on GC. It is also used by NIO objects to speed up operations on files or sockets.
	
	--- Garbage Collector (https://dzone.com/articles/minor-gc-vs-major-gc-vs-full)
		Garbage Collector is the program running in the background that looks into all the objects in the memory and find out objects that are not referenced by any part of the program. 
		Minor GC for Young Generation(Since Young generation keeps short-lived objects, Minor GC is very fast), Major GC for Old Generation(Major GC takes longer time because it checks all the live objects)
		----  http://ggenikus.github.io/blog/2014/05/04/gc
			Существует два подхода к обнаружению мусора:
			-- Tracing
			В “Tracing” главная идея состоит в мысли: “Живые объект - те до которых мы можем добраться с корневых точек (GC Root: Локальные переменные и параметры методов, Java Потоки, Статические переменные, Ссылки из JNI)
			В HotSpot VM реализовано четыре сборщика мусора основанных на идее “Generational Garbage Collection”: Serial GC, Parallel GC, CMS GC, G1 GC
			-- Reference counting не використовується

		JVM uses TWO different Garbage Collectors for Young and Old Generations. https://stackoverflow.com/questions/16549066/java-major-and-minor-garbage-collections
		HotSpot(https://stackoverflow.com/questions/16568253/difference-between-jvm-and-hotspot) is an an implementation of the JVM concept. It was originally developed by Sun and now it is owned by Oracle. 
			There are other implementations of the JVM specification, like JRockit, IBM J9, among many others.
    ------------------- JIT(https://www.quora.com/What-is-JIT-Compiler-In-Java)
	--- The Just-In-Time (JIT) compiler (https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.vm.80.doc/docs/jit_overview.html) is a component of the Java™ Runtime Environment 
		that improves the performance of Java applications at run time. In the Java programming language and environment, a just-in-time (JIT) compiler is a program that turns Java bytecode 
		(a program that contains instructions that must be interpreted) into instructions that can be sent directly to the processor. 
		After you've written a Java program, the source language statements are compiled by the Java compiler into bytecode rather than into code that contains instructions that match a particular hardware platform's processor

		Bytecode(https://en.wikipedia.org/wiki/Bytecode), also termed portable code or p-code, is a form of instruction set designed for efficient execution by a software interpreter. 
			Unlike human-readable source code, bytecodes are compact numeric codes, constants, and references (normally numeric addresses) 
			that encode the result of compiler parsing and performing semantic analysis of things like type, scope, and nesting depths of program objects.
			
		Interpreter(https://en.wikipedia.org/wiki/Interpreter_(computing)) is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, 
			without requiring them previously to have been compiled into a machine language program.
			
		Machine code(https://en.wikipedia.org/wiki/Machine_code) is a computer program written in machine language instructions that can be executed directly by a computer's central processing unit (CPU). 
			Each instruction causes the CPU to perform a very specific task, such as a load, a jump, or an ALU operation on a unit of data in a CPU register or memory.	

		-server and -client(https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-1-jvm-types-and-compiler-modes/)
			
	------------------- There are three types of built-in ClassLoader in Java(https://www.baeldung.com/java-classloaders, https://javarush.ru/groups/posts/646-kak-proiskhodit-zagruzka-klassov-v-jvm, http://www.640kb.club/post/classloader-I/):
		Bootstrap Class Loader – It loads JDK internal classes, typically loads rt.jar and other core classes for example java.lang.* package classes(https://www.quora.com/What-is-rt-jar-in-Java)
		Extensions Class Loader – It loads classes from the JDK extensions directory, usually $JAVA_HOME/lib/ext directory.
		System Class Loader – It loads classes from the current classpath that can be set while invoking a program using -cp or -classpath command line options.	

		(https://www.artima.com/insidejvm/ed2/lifetype.html)
		The Java virtual machine makes types available to the running program through a process of loading, linking, and initialization. 
		Loading is the process of bringing a binary form for a type into the Java virtual machine. 
		Linking is the process of incorporating the binary type data into the runtime state of the virtual machine. 
			Linking is divided into three sub-steps: verification, preparation, and resolution. 
				Verification ensures the type is properly formed and fit for use by the Java virtual machine. 
				Preparation involves allocating memory needed by the type, such as memory for any class variables. 
				Resolution is the process of transforming symbolic references in the constant pool into direct references. 
			Implementations may delay the resolution step until each symbolic reference is actually used by the running program. 
			After verification, preparation, and (optionally) resolution are completed, the type is ready for initialization. 
		During initialization, the class variables are given their proper initial values. 

		VM SWITCH        			VM SWITCH DESCRIPTION
		-Xms        				For setting the initial heap size when JVM starts
		-Xmx        				For setting the maximum heap size.
		-Xmn        				For setting the size of the Young Generation, rest of the space goes for Old Generation.
		-XX:PermGen        			For setting the initial size of the Permanent Generation memory
		-XX:MaxPermGen        		For setting the maximum size of Perm Gen
		-XX:SurvivorRatio        	For providing ratio of Eden space and Survivor Space, for example if Young Generation size is 10m and VM switch is -XX:SurvivorRatio=2 
			then 5m will be reserved for Eden Space and 2.5m each for both the Survivor spaces. The default value is 8.
		-XX:NewRatio        		For providing ratio of old/new generation sizes. The default value is 2.

------------------- OutOfMemoryError in Java (https://javarevisited.blogspot.com/2011/09/javalangoutofmemoryerror-permgen-space.html)
		Types of OutOfMemoryError in Java
		I have seen mainly two types of OutOfMemoryError in Java:

		1) The java.lang.OutOfMemoryError: Java heap space
		2) The java.lang.OutOfMemoryError: PermGen space
	
		How to solve java.lang.OutOfMemoryError: Java heap space	
		1) An easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options "-Xmx512M", this will immediately solve your OutOfMemoryError.

Read more: https://javarevisited.blogspot.com/2011/09/javalangoutofmemoryerror-permgen-space.html#ixzz5WqK4p07j
Video: https://www.youtube.com/watch?v=QHIWkwxs0AI, https://www.youtube.com/watch?v=QHKJ9VJHIuY

------------------- Memory Leaks (https://stackify.com/memory-leaks-java/)
		Static Field Holding On to the Object Reference
		Calling String.intern() on Long String
		Unclosed Streams
		Unclosed Connections
		Adding Objects with no hashCode() and equals() into a HashSet
	
------------------- How does Java Garbage Collection work with Circular References? (https://stackoverflow.com/questions/1910194/how-does-java-garbage-collection-work-with-circular-references)
		Java's GC considers objects "garbage" if they aren't reachable through a chain starting at a garbage collection root, so these objects will be collected. 
			Even though objects may point to each other to form a cycle, they're still garbage if they're cut off from the root.
References: https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html
			
-- ------------------------------------------------ 4 типа ссылок на объекты
В Java существует 4 типа ссылок на объекты:
strong reference
soft reference
SoftReference<Rectangle> rect = new SoftReference<Rectangle>(new Rectangle());
Это происходит в том случае, когда память вашей программы заполнена и появляется вероятность возникновения OutOfMemoryError, тогда сборщик мусора удаляет объекты на которые ссылаются мягкие ссылки. 
Именно этот вид ссылок удобно использовать для кеширования объектов.
weak reference
WeakReference<Rectangle> rect = new WeakReference<Rectangle>(new Rectangle());
Разница в том, что объект на который ссылается слабая ссылка может быть удален в любой момент при вызове cборщика мусора, т.е. для этого не обязательно условие нехватки памяти.
phantom reference
http://www.quizful.net/interview/java/reference-types
https://habrahabr.ru/post/169883/
So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. Phantom references don’t free the reference until cleared.
https://dou.ua/forums/topic/6267/, https://medium.com/@ramtop/weak-soft-and-phantom-references-in-java-and-why-they-matter-c04bfc9dc792
https://www.logicbig.com/tutorials/core-java-tutorial/gc/phantom-reference.html

-- ------------------------------------------------ Java Enum (http://tutorials.jenkov.com/java/enums.html)
		Java Enum was introduced in Java 1.5 as a new type whose fields consists of fixed set of constants.
		A Java Enum is a special Java type used to define collections of constants. More precisely, a Java enum type is a special kind of Java class. 
		An enum can contain constants, methods etc. Java enums were added in Java 5.

-- ------------------------------------------------ Java Ternary Operator
		Java ternary operator is the only conditional operator that takes three operands.
		result = testStatement ? value1 : value2;

-- ------------------------------------------------ Lazy initialization(https://en.wikipedia.org/wiki/Lazy_initialization)
		In computer programming, lazy initialization is the tactic of delaying the creation of an object, the calculation of a value, 
			or some other expensive process until the first time it is needed. 
			It is a kind of lazy evaluation that refers specifically to the instantiation of objects or other resources.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------				
When to use LinkedList and when to use ArrayList?
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	1) As explained above the insert and remove operations give good performance (O(1)) in LinkedList compared to ArrayList(O(n)). 
		Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.
	2) Search (get method) operations are fast in Arraylist (O(1)) but not in LinkedList (O(n)) so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.

-- ------------------------------------------------ LIFO и FIFO
LIFO (акроним Last In, First Out, «последним пришёл — первым ушёл») 
FIFO (акроним англ. First In, First Out – первым пришёл — первым ушёл)

-- ------------------------------------------------ POJO (англ. Plain Old Java Object) 
„Простий старий Java-об'єкт“, простий Java-об'єкт, не успадкований від якогось специфічного об'єкта і який не реалізує жодних службових інтерфейсів окрім тих, які потрібні для бізнес-моделі.
		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Collection Framework(http://www.quizful.net/post/Java-Collections, https://www.bigocheatsheet.com/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------	Understanding Natural Ordering(https://www.codejava.net/java-core/collections/understanding-object-ordering-in-java-with-comparable-and-comparator)
			Natural ordering is the default ordering of objects of a specific type when they are sorted in an array or a collection. 
			- The natural ordering of String objects is alphabetic order.
			- The natural ordering of Integer objects is alphanumeric order.
			- The natural ordering of Date objects is chronological order.

			Remember these rules:
			compare value = 0: two objects are equal.
			compare value > 0: the first object (the current object) is greater than the second one.
			compare value < 0: the first object is less than the second one.

-------------------	Big-O (https://www.bigocheatsheet.com/)

-------------------	Comparator vs Comparable (https://www.baeldung.com/java-comparator-comparable)
		Comparable is an interface defining a strategy of comparing an object with other objects of the same type. This is called the class's “natural ordering”.
		public class Player implements Comparable<Player> {
			//...
			@Override
			public int compareTo(Player otherPlayer) {
				return (this.getRanking() - otherPlayer.getRanking());
			}
		}
		The Comparator interface defines a compare(arg1, arg2) method with two arguments which represent compared objects and works similarly to the Comparable.compareTo() method.
		public class PlayerRankingComparator implements Comparator<Player> {
			@Override
			public int compare(Player firstPlayer, Player secondPlayer) {
			   return (firstPlayer.getRanking() - secondPlayer.getRanking());
			}
		}
		The Comparable interface is a good choice when used for defining the default ordering or, in other words, if it's the main way of comparing objects.
			Then, we must ask ourselves why use a Comparator if we already have Comparable?
			There are several reasons why:
				Sometimes, we can't modify the source code of the class whose objects we want to sort, thus making the use of Comparable impossible
				Using Comparators allows us to avoid adding additional code to our domain classes
				We can define multiple different comparison strategies which isn't possible when using Comparable	
	
-------------------	Java 7 uses Dual-Pivot Quicksort for primitives and TimSort for objects.(https://stackoverflow.com/questions/4018332/is-java-7-using-tim-sort-for-the-method-arrays-sort)
		According to the Java 7 API doc for primitives:
			Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. 
			This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
			
			Aлгоритм dual-pivot quicksort(https://habrahabr.ru/post/69424/)
				Обычный quicksort делит массив на два отрезка, выбрав случайный элемент P. 
				Потом сортирует массив так, чтобы все элементы меньше P попали в первый отрезок, а остальные — во второй. 
				Затем алгоритм рекурсивно повторяется на первом и на втором отрезках.
				
			As mentioned in the official JavaDoc, Arrays.sort uses dual-pivot Quicksort on primitives. It offers O(n log(n)) (https://www.baeldung.com/java-sorting)
			Java 8 comes with a new API – parallelSort – with a similar signature to the Arrays.sort()
			
		According to the Java 7 API doc for objects:
			The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techiques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", 
			in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
			
			Алгоритм Timsort(https://neerc.ifmo.ru/wiki/index.php?title=Timsort): 
				Шаг 1. Входной массив разделяется на подмассивы фиксированной длины, вычисляемой определённым образом.
				Шаг 2. Каждый подмассив сортируется сортировкой вставками, сортировкой пузырьком или любой другой устойчивой сортировкой.
				Шаг 3. Отсортированные подмассивы объединяются в один массив с помощью модифицированной сортировки слиянием.
				TimSort is a sorting algorithm based on Insertion Sort and Merge Sort.(https://www.geeksforgeeks.org/timsort/)
					Insertion Sort is a simple sorting algorithm that works the way we sort playing cards in our hands.https://www.geeksforgeeks.org/insertion-sort/
					
		https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html - visualisation
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Iterator In Java (Fail Fast and Fail Safe ) 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html
        
        Fail fast iterator while iterating through the collection , instantly throws ConcurrentModificationException if there is structural modification  of the collection.(java.util.HashMap)
            (Поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом.)
        Fail Safe Iterator makes copy of the internal data structure (object array) and iterates over the copied data structure.(java.util.concurrent.ConcurrentHashMap)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	HashMap (https://dzone.com/articles/hashmap-internal)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		collision - when there are different keys with the same same hashcode, internally, we use a single linked list to store elements.
		default size of an hashmap as 16 (always a power of 2) and the load factor as 0.75,	

		But Java 8 has come with the following new strategy for HashMap objects in case of high collisions.(https://www.dineshonjava.com/hashmap-performance-improvement-changes-in-java-8/)
			To address this issue, Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is reached. 
				Which means HashMap starts with storing Entry objects in a linked list but after the number of items in a hash becomes larger than a certain threshold. 
				The hash will change from using a linked list to a balanced tree.
			Above changes ensure the performance of O(log(n)) in worst case scenarios and O(1) with proper hashCode().
			The alternative String hash function added in Java 7 has been removed.		
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Annotations(http://tutorials.jenkov.com/java/annotations.html)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		Java annotations are typically used for the following purposes:
			Compiler instructions
			Build-time instructions
			Runtime instructions (These annotations can then be accessed via Java Reflection)
		You can place Java annotations above classes, interfaces, methods, method parameters, fields and local variables.
		Java comes with three built-in annotations which are used to give the Java compiler instructions. These annotations are:
			@Deprecated is used to mark a class, method or field as deprecated, meaning it should no longer be used.
			@Override is used above methods that override methods in a superclass.
			@SuppressWarnings if a method calls a deprecated method, or makes an insecure type cast, the compiler may generate a warning. 
				You can suppress these warnings by annotating the method containing the code with the @SuppressWarnings annotation.
				
		Annotations are defined in their own file, just like a Java class or interface. Here is custom Java annotation example:
			@interface MyAnnotation {
				String   value();
			}
		Own Annotations
			@Retention
				A retention policy determines at what point annotation should be discarded. (http://www.java2novice.com/java-annotations/retention-policy/)
					Java defined 3 types of retention policies through java.lang.annotation.RetentionPolicy enumeration. It has SOURCE, CLASS and RUNTIME.
					Annotation with retention policy SOURCE will be retained only with source code, and discarded during compile time.
					Annotation with retention policy CLASS will be retained till compiling the code, and discarded during runtime.
					Annotation with retention policy RUNTIME will be available to the JVM through runtime.
					The retention policy will be specified by using java built-in annotation @Retention, and we have to pass the retention policy type.
					The default retention policy type is CLASS.
			@Target
				You can specify which Java elements your custom annotation can be used to annotate. You do so by annotating your annotation definition with the @Target annotation. 
					ElementType.ANNOTATION_TYPE
					ElementType.CONSTRUCTOR
					ElementType.FIELD
					ElementType.LOCAL_VARIABLE
					ElementType.METHOD
					ElementType.PACKAGE
					ElementType.PARAMETER
					ElementType.TYPE
			@Inherited
				The @Inherited annotation signals that a custom Java annotation used in a class should be inherited by subclasses inheriting from that class.
			@Documented
				The @Documented annotation is used to signal to the JavaDoc tool that your custom annotation should be visible in the JavaDoc for classes using your custom annotation.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Exceptions(http://tutorials.jenkov.com/java-exception-handling/exception-wrapping.html)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	

Finally
	You can attach a finally-clause to a try-catch block. The code inside the finally clause will always be executed, even if an exception is thrown from within the try or catch block.
Propagating Exceptions
	You don't have to catch exceptions thrown from other methods. If you cannot do anything about the exception where the method throwing it is called, 
		you can just let the method propagate the exception up the call stack to the method that called this method.
    public void callDivide() throws BadNumberException{}
Catching Exceptions
	If a method calls another method that throws checked exceptions, the calling method is forced to either pass the exception on, or catch it. 
		Catching the exception is done using a try-catch block.
Throwing Exceptions
	If a method needs to be able to throw an exception, it has to declare the exception(s) thrown in the method signature, and then include a throw-statement in the method.
	public void callDivide() throws BadNumberException{
		throw new BadNumberException("...");
	}
The Call Stack Explained
	This text refers to the concept the "call stack" in several places. 
		By the call stack is meant the sequence of method calls from the current method and back to the Main method of the program.
Using Multiple Resources
	You can use multiple resources inside a try-with-resources block and have them all automatically closed. 
		private static void printFileJava7() throws IOException {
			try(  FileInputStream     input         = new FileInputStream("file.txt");
				  BufferedInputStream bufferedInput = new BufferedInputStream(input)
			) {

				int data = bufferedInput.read();
				while(data != -1){
					System.out.print((char) data);
					data = bufferedInput.read();
				}
			}
		}
	When the try block finishes the FileInputStream will be closed automatically. 
		This is possible because FileInputStream implements the Java interface java.lang.AutoCloseable. 
		All classes implementing this interface can be used inside the try-with-resources construct.

Catching Multiple Exceptions in Java 7
	In Java 7 it was made possible to catch multiple different exceptions in the same catch block. This is also known as multi catch.
			try {
				...
			} catch(SQLException | IOException e) {
			} catch(Exception e) {
			} finally {
				...
			}
			
Explain Java Exception Hierarchy?(https://www.journaldev.com/2167/java-exception-interview-questions-and-answers)
	Java Exceptions are hierarchical and inheritance is used to categorize different types of exceptions. 
		Throwable is the parent class of Java Exceptions Hierarchy and it has two child objects – Error and Exception. 
		Exceptions are further divided into checked exceptions and runtime exception.
	Errors are exceptional scenarios that are out of scope of application and it’s not possible to anticipate and recover from them, for example hardware failure, JVM crash or out of memory error.

Checked or Unchecked Exceptions
	In Java there are basically two types of exceptions: Checked exceptions and unchecked exceptions:
		Checked exceptions must be explicitly caught or propagated as described in Basic try-catch-finally Exception Handling. 
		Unchecked exceptions do not have this requirement. They don't have to be caught or declared thrown.
		Checked exceptions in Java extend the java.lang.Exception class. 
		Unchecked exceptions extend the java.lang.RuntimeException.		

		Checked and unchecked exceptions are functionally equivalent. 
		There is nothing you can do with checked exceptions that cannot also be done with unchecked exceptions, and vice versa.		
What is Exception Wrapping?
	Exception wrapping is a standard feature in Java since JDK 1.4. 
	Most (if not all) of Java's built-in exceptions has constructors that can take a "cause" parameter. 
	They also have a getCause() method that will return the wrapped exception.
		    try{
				...
			} catch (SQLException sqlException) {
				throw new MyException("error text", sqlException);
			}
Fail Safe Exception Handling
	The last exception thrown in a try-catch-finally block is the exception that will be propagated up the call stack.
	All earlier exceptions will disappear.
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
String 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Java String Pool (https://www.baeldung.com/java-string-pool) — the special memory region where Strings are stored by the JVM. 
		Palindrome (https://www.baeldung.com/java-palindrome)
			A palindrome is a word, phrase, number, or other sequences of characters which reads the same backward as forward, such as “madam” or “racecar”.
			public boolean isPalindromeUsingStringBuilder(String text) {
				String clean = text.replaceAll("\\s+", "").toLowerCase();
				StringBuilder plain = new StringBuilder(clean);
				StringBuilder reverse = plain.reverse();
				return (reverse.toString()).equals(clean);
			}
			
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Difference between URL and URI(https://prateekvjoshi.com/2014/02/22/url-vs-uri-vs-urn/, http://www.baeldung.com/java-url-vs-uri, https://stackoverflow.com/questions/4913343/what-is-the-difference-between-uri-url-and-urn)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		The difference between them is straightforward after knowing their definitions:
			Uniform Resource Identifier (URI) − a sequence of characters that allows the complete identification of any abstract or physical resource
			Uniform Resource Locator (URL) − a subset of URI that, in addition to identifying where a resource is available, describes the primary mechanism to access it
			Uniform Resource Name(URN) - it identifies a resource by name in a given namespace. 
		Now we can conclude that every URL is a URI and URN, but the opposite is not true, as we’ll see later.
		
		Every URI, regardless if it’s a URL or not, follows a particular form:
			scheme:[//authority][/path][?query][#fragment]
			Where each part is described as follows:
				scheme − for URLs, is the name of the protocol used to access the resource, for other URIs, is a name that refers to a specification for assigning identifiers within that scheme
				authority − an optional part comprised of user authentication information, a host and an optional port
				path − it serves to identify a resource within the scope of its scheme and authority
				query − additional data that, along with the path, serves to identify a resource. For URLs, this is the query string
				fragment − an optional identifier to a specific part of the resource
				
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Embedded Databases(https://techshard.com/2017/04/01/3-embedded-databases-in-java/)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	HSQLDB (HyperSQL Database)(https://ru.wikipedia.org/wiki/HSQLDB),
	H2(https://ru.wikipedia.org/wiki/H2),
	Apache Derby(https://ru.wikipedia.org/wiki/Apache_Derby)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JNDI(https://docs.oracle.com/javase/tutorial/jndi/overview/index.html)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Java Naming and Directory Interface (JNDI) — это набор Java API, организованный в виде службы каталогов, который позволяет Java-клиентам открывать и просматривать данные и объекты по их именам.
	The Java Naming and Directory Interface™ (JNDI) is an application programming interface (API) that provides naming and directory functionality to applications written using the Java™ programming language.
		It is defined to be independent of any specific directory service implementation. Thus a variety of directories -new, emerging, and already deployed can be accessed in a common way.
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JMX (Java Management Extensions) (https://urvanov.ru/2018/05/05/%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-jmx-%D0%B8-mbeans-%D0%B2-java/, https://www.codeflow.site/ru/article/java-management-extensions)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	Java Management Extensions (JMX) — это технология, входящая в J2SE начиная с J2SE 5.0. JMX предназначен для контроля и управления приложениями, системными объектами, устройствами (например, принтерами) и компьютерными сетями.